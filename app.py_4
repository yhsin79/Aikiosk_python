from flask import Flask, Response, jsonify, render_template
import face_recognition
import cv2
import os
import json
from datetime import datetime
from flask_mysqldb import MySQL
import time
from scipy.spatial import distance  # ìœ ì‚¬ë„ ë¹„êµìš©

app = Flask(__name__)

# MySQL ì„¤ì •
app.config['MYSQL_HOST'] = 'localhost'
app.config['MYSQL_PORT'] = 3306  
app.config['MYSQL_USER'] = 'root'
app.config['MYSQL_PASSWORD'] = 'cindykangnam1!2@'
app.config['MYSQL_DB'] = 'aikiosk_db'

mysql = MySQL(app)

# ì „ì—­ ë³€ìˆ˜
check_start_time = None
person_detected = False
matched_once = False  # ì¤‘ë³µ ë§¤ì¹­ ë°©ì§€

matched_result = None  # None, "matched", "not_matched"
new_face_id = None #dbì— insertë¡œ ì¶”ê°€í•œ new_face_id

@app.route('/get_data')
def get_data():
    cur = mysql.connection.cursor()
    cur.execute("SELECT * FROM coffee_menu")
    data = cur.fetchall()
    cur.close()
    return jsonify(data)

@app.route('/detect_person')
def detect_person():
    global person_detected, matched_result, new_face_id
    result = matched_result
    matched_result = None  # ê²°ê³¼ëŠ” í•œ ë²ˆë§Œ ì‚¬ìš©ë˜ë„ë¡ ì´ˆê¸°í™”
    face_id = new_face_id

    return jsonify({
        'detected': person_detected,
        'match_result': result,  # "matched", "not_matched", None
        'new_face_id': face_id # ìƒˆë¡œ ë“±ë¡ëœ ID (ì—†ìœ¼ë©´ null)
    })

def gen_frames():
    global person_detected, matched_once, check_start_time, matched_result

    cap = cv2.VideoCapture(0)

    inserted = False 

    while True:
        success, frame = cap.read()
        if not success:
            break

        face_locations = face_recognition.face_locations(frame)
        person_detected = len(face_locations) > 0

        #ì‚¬ëŒì„ ê°ì§€í–ˆëŠ”ì§€ ì—¬ë¶€
        if person_detected and not matched_once:
            if check_start_time is None:
                check_start_time = time.time()

        elapsed = time.time() - check_start_time if check_start_time else 0

        for (top, right, bottom, left) in face_locations:
            cv2.rectangle(frame, (left, top), (right, bottom), (0, 255, 0), 2)

            # ì–¼êµ´ ìœ„ì— "Checking~" í‘œì‹œ (3ì´ˆê°„)
            if not matched_once and elapsed < 3:
                cv2.putText(frame, "Checking~", (left, top - 10), cv2.FONT_HERSHEY_SIMPLEX,
                            1.0, (0, 255, 255), 2)

            # 3ì´ˆ í›„ ì–¼êµ´ ë¹„êµ ì‹œì‘
            elif not matched_once and elapsed >= 3:

                #ì–¼êµ´ ì¸ì½”ë”©
                face_image = frame[top:bottom, left:right]
                rgb_face_image = cv2.cvtColor(face_image, cv2.COLOR_BGR2RGB)
                face_encoding = face_recognition.face_encodings(rgb_face_image)

                if face_encoding and not inserted:
                    print("âœ… ì–¼êµ´ ì¸ì½”ë”© ì„±ê³µ")
                    vector = face_encoding[0]
                    json_vector = json.dumps(vector.tolist())

                    # ì–¼êµ´ ì´ë¯¸ì§€ ì €ì¥
                    face_image = frame[top:bottom, left:right]
                    folder_path = os.path.join("static", "faces")
                    os.makedirs(folder_path, exist_ok=True)
                    
                    now = datetime.now()
                    timestamp_str = now.strftime("%Y%m%d_%H%M%S")
                    
                    
                    filename = f"face_{timestamp_str}.jpg"
                    save_path = os.path.join(folder_path, filename)
                    cv2.imwrite(save_path, face_image)
                    print(f" ì–¼êµ´ ì´ë¯¸ì§€ ì €ì¥ë¨: {save_path}")

                    try:
                        with app.app_context():
                            cur = mysql.connection.cursor()
                            cur.execute(
                                "INSERT INTO detected_faces (image_path, detected_time, face_vector) VALUES (%s, %s, %s)",
                                (save_path, now, json_vector)
                            )
                            mysql.connection.commit()
                            new_id = cur.lastrowid
                            print(f"âœ… ì–¼êµ´ ë“±ë¡ ì™„ë£Œ - ID: {new_id}")
                            global new_face_id
                            new_face_id = new_id
                            
                            cur.close()
                        inserted = True
                    except Exception as e:
                        print("âŒ ë“±ë¡ ì‹¤íŒ¨:", e)



                    with app.app_context():
                        cur = mysql.connection.cursor()
                        cur.execute("SELECT id, face_vector FROM detected_faces")
                        rows = cur.fetchall()

                        min_distance = float('inf')
                        matched_id = None

                        for row in rows:
                            db_id = row[0]
                            db_vector_json = row[1]
                            db_vector = json.loads(db_vector_json)
                            dist = distance.euclidean(vector, db_vector)

                            #print(f"ğŸ‘¤ ID {db_id} ê±°ë¦¬: {dist}")
                            if dist < min_distance:
                                min_distance = dist
                                matched_id = db_id

                        if min_distance < 0.6:
                           
                            # í›„ë³´ëŠ” ì°¾ì•˜ìŒ â†’ ì£¼ë¬¸ ì´ë ¥ ì—¬ë¶€ í™•ì¸
                            with app.app_context():
                                cur.execute("SELECT COUNT(*) FROM coffee_order WHERE face_id = %s", (matched_id,))
                                order_count = cur.fetchone()[0]

                            if order_count > 0:
                                print(f"ğŸ¯ ì¼ì¹˜í•˜ëŠ” ì‚¬ìš©ì ID: {matched_id} (ì£¼ë¬¸ ì´ë ¥ ìˆìŒ)")
                                matched_result = "matched"
                            else:
                                print(f"ğŸ˜• ì–¼êµ´ì€ ìœ ì‚¬í•˜ì§€ë§Œ ì£¼ë¬¸ ì´ë ¥ì´ ì—†ìŒ â†’ not matched")
                                matched_result = "not_matched"
                            #print(f"ğŸ¯ ì¼ì¹˜í•˜ëŠ” ì‚¬ìš©ì ID: {matched_id} (ê±°ë¦¬: {min_distance:.4f})")
                            #matched_result = "matched"
                        else:
                           
                            print("ğŸ˜• ìœ ì‚¬í•œ ì–¼êµ´ì´ ì—†ìŠµë‹ˆë‹¤.")
                            matched_result = "not_matched"

                        matched_once = True
                        cur.close()

        # í”„ë ˆì„ ì¸ì½”ë”©
        ret, buffer = cv2.imencode('.jpg', frame)
        frame = buffer.tobytes()

        # MJPEG ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ
        yield (b'--frame\r\n'
               b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n')

    cap.release()

@app.route('/')
def index():
    return render_template('index.html')
    #return "<h2>ì‹¤ì‹œê°„ ì–¼êµ´ ì¸ì‹ í…ŒìŠ¤íŠ¸</h2><img src='/video'>"

@app.route('/video')
def video():
    return Response(gen_frames(), mimetype='multipart/x-mixed-replace; boundary=frame')




if __name__ == '__main__':
    app.run('0.0.0.0', port=5001, debug=True)
